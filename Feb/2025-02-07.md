# TIL Template

## 날짜: 2025-02-07

### 스크럼
- 학습 목표 1 : 딥 다이브 내용 정리
- 학습 목표 2 : SQLD 학습

### 새로 배운 내용
#### 주제 1: 2주차 딥 다이브
- NumPy 배열의 생성과 연산이 데이터를 어떻게 처리하는지 설명하시오.</br>

  *NumPy 배열은 동일한 데이터 타입을 가진 배열로 연속된 메모리 블록에 저장하여 벡터화 연산 등의 작업으로 데이터를 메모리 효율적으로 처리한다.*
  1. 배열의 생성 **The N-dimensional array**(`ndarray`)</br>
     ![alt text](/Feb/image/image-8.png)</br>
     NumPy의 배열인 `ndarray`는 **동일한 데이터 타입**을 가진 배열로 데이터를 효율적으로 저장하고 연산하기 위한 기본 자료구조이다. 동일한 `dtype`을 가지기 때문에 각 블록마다 크기를 고정시킬 수 있다. 따라서 메모리 블록을 연속적으로 만들 수 있어 효율적으로 저장하고 연산하는 것이 가능해진다.
     ```python
     ndarray = np.array([1, 2, 3], dtype = np.int32)
     ```
     해당 `ndarray`의 경우 각 4bytes 씩 메모리에 연속적으로 배치된다. 따라서 값들을 참조하기 쉽다.</br>
     반면, 일반적인 Python의 `list`는 내부적으로는 실제 데이터가 저장된 객체를 가리키는 포인터이다.
     ```python
     pylist = [1, "String", 'A', 3.14, [1, 2, 3]]
     ```
     해당 `list`는 동적으로 크기가 늘어나도록 설계되어 있으며 순수 값만 저장되는 `ndarray`와 달리 각 객체에 대한 헤더와 참조 카운트 등이 필요로 하다.</br>
     같은 힙 메모리지만 바로 옆에 붙어있는 것과 포인터만 있는 것은 다르다.</br>


     단, 메모리 블록을 연속적으로 만들기 때문에 동적 메모리인 `list`처럼 요소를 추가하거나 삭제할 수 없다. `np.append()`, `np.delete()`는 `view`타입이다.
     ```python
     import numpy as np

     pylist = [1, 2, 3]
     pylist.append(4)

     print(pylist, '\n')

     ndarray = np.array([1, 2, 3], dtype = np.int32)
     np.append(ndarray, 4)

     print(ndarray)
     print(np.append(ndarray, 4))
     ```
     ```
     [1, 2, 3, 4]

     [1 2 3]
     [1 2 3 4]
     ```


     ---

  2. 배열의 연산</br>
     배열에 대한 연산이 필요할 때, `ndarray`의 경우 헤더만 참조하여 같은 `dtype`인지 확인하고 연산할 수 있다. 하지만 일반적인 Python `list`의 경우 동적 타입 검사가 필요하다. 즉, 반복문 작업이 추가적으로 필요하다.
     
     벡터화란 배열의 각 원소에 대해 일괄적으로 연산을 수행하는 방식을 의미한다. 일반적으로 Python에서는 반복문을 사용하여 하나하나 연산하는 반면 NumPy는 C나 Fortran으로 구현된 최적화된 내부 루틴을 사용하여 전체 배열을 한 번에 처리한다.
     ```python
     pylist1 = [1, 2, 3, 4]
     pylist2 = [10, 20, 30, 40]

     print(pylist1 + pylist2)
     ```
     ```
     [1, 2, 3, 4, 10, 20, 30, 40]
     ```
     합을 구현하려면 `for`문과 같은 반복문이 필수적이다.
     ```python
     pylist3 = []
     for i in range(len(pylist1)):
      pylist3.append(pylist1[i] + pylist2[i])

     print(pylist3)
     ```
     ```
     [11, 22, 33, 44]
     ```
     하지만 NumPy는 벡터화를 통해 연산을 수행하기 때문에 바로 계산이 가능하다.
     ```python
     import numpy as np

     array1 = np.array(pylist1)
     array2 = np.array(pylist2)

     print(array1 + array2)
     ```
     ```
     [11 22 33 44]
     ```
     위와 같은 벡터 연산을 지원하는 유니버설 함수(Universal Function)이 존재한다.</br>
     이러한 벡터화의 장점은 전체 배열을 한번에 처리하기 때문에 매우 빠른 연산이 가능하고 복잡한 루프를 작성할 필요가 없어 가독성이 높아진다.</br>
     이런 벡터화 계산 방식이 가능한 이유도 메모리 레이아웃 덕분이다.

     브로드캐스팅을 사용해 서로 다른 모양의 배열 간에도 자동으로 차원을 맞추어 연산할 수 있어 효율적인 수치 계산을 할 수 있다.
     

- 상세 내용 2
- 상세 내용 3

#### 주제 2: SQLD Entity, Attribute, Relationship
## 엔터티(Entity)
  - 현실 세계에서 독립적으로 식별 가능한 객체나 사물을 나타냄
  - 엔터티는 업무상 분석해야하는 대상(Instance)들로 이루어진 집합
  - 인스턴스는 엔터티의 특정한 속성 값들로 굿어되며, 엔터티의 개념을현실에서 구체적으로 나타낸 것</br>

    |명명|예시|
    |--|--|
    |엔터티|학생|
    |속성|학번, 이름, 학과 등|
    |식별자|학번(고유한 학번으로 각 학생을 식별)|
    |인스턴스|특정 학생의 데이터|

  - 엔터티의 특징
    1. 유일한 식별자에 의해 식별가능
        - 인스턴스가 식별자에 의해 한 개씩만 존재하는 지 검증 필요
        - 유일한 식별자는 그 엔터티의 인스턴스만의 고유 이름</br>
          ex) 이름은 동명이인이 있을 수 있으므로 사번, 학번 등의 고유식별자 필요
    2. 해당 업무에 필요하고 관리하고자 하는 정보
        - 설계하는 업무의 시스템 구축에 필요한 정보여야함
          ex) 학교 시스템 구축 시 학생정보 필요. 다른 업무엔 학생 정보 불필요
    3. 인스턴스들의 집합
        - 영속적으로 존재하는 2개 이상의 인스턴스의 집합
        - 인스턴스가 한 개 밖에 없는 엔터티는 집합이 아니므로 성립이 안됨
    4. 엔터티는 반드시 속성을 가짐
        - 각 엔터티는 2개 이상의 속성을 가짐
        - 하나의 인스턴스는 각각의 속성들에 대한 1개의 속성 값만을 가짐
          ex) 학생 엔터티에서 한 학생의 데이터(인스턴스)의 이름(속성) 정보에는 반드시 한 값만 저장됨</br>
          ![alt text](/Feb/image/image-9.png)</br>
    5. 엔터티는 업무 프로세스에 의해 이용
        - 업무적으로 필요해 선정했지만 실제 사용되지 않으면 잘못 설계된 것
        - 모델링 시 발견하기 어려운 경우 데이터 모델 검증이나 상관 모델링 시 단위 프로세스 교차점금으로 문제도출
        - 누락된 프로세스의 경우 추후 해당 프로세스 추가
        - 반대로 사용되지 않는 고립 엔터티는 제거 필요
    6. 다른 엔터티와 최소 1개 이상의 관계 성립
        - 인터티는 업무적 연관성을 갖고 다른 엔터티와 연관의 의미를 가짐
        - 관계가 없는 엔터티 도출은 부적절한 엔터티이거나 적절한 관계를 찾지 못한 것

  - 엔터티의 분류
    1. 유형과 무형에 따른 분류

    |분류명|설명|
    |--|--|
    |유형 엔터티|**물리적 형태가 있는 실체가 있는 대상**</br> 안정적이며 지속적으로 활용되는 엔터티</br> 업무로부터 구분하기가 가장 용이한 엔터티</br> ex) 사원, 물품, 감사 등|
    |개념 엔터티|**물리적인 형태가 없음**</br> 관리해야 할 개념적 정보로부터 구분되는 엔터티</br> ex) 조직, 보험상품 등|
    |사건 엔터티|**업무를 수행에 따라 발생하는 엔터티**</br> 발생량이 많고 각종 통계자료에 이용</br> ex) 주문, 청구, 미납 등|

    2. 발생 시점에 따른 분류

    |분류명|설명|
    |--|--|
    |기본 엔터티|**그 업무에 원래 존재하는 정보**</br> 다른 엔터티와 관계에 의해 생성되지 않고 독립적으로 생성</br> 타 엔터티의 부모 역할을 하는 엔터티</br> 다른 엔터티로부터 주식별자를 상속받지 않고 **자신의 고유한 주식별자를 가짐**</br> ex) 사원, 부서, 고객, 상품 등|
    |중심 엔터티|**기본 엔터티로부터 발생되고 그 업무에서 중심적인 역할**</br> 많은 데이터가 발새오디고 다른 엔터티와의 관계를 통해 많은 행위 엔터티를 생성</br> ex) 계약, 사고, 청구, 주문, 매출 등|
    |행위 엔터티|**2개 이상의 부모 엔터테로부터 발생**</br> 자주 내용이 바뀌거나 데이터 양이 증가</br> 분석 초기 단계보다는 상세 설계 단계나 프로세스와 상관 모델링을 진행하면서 도출</br> ex) 주문(고객과 상품 엔터티로 부터 발생하므로 해위 엔터티이기도 함), 사원 변경이력, 이력 등|

  - 엔터티의 명명
    1. 현업에서 사용하는 용어 사용
    2. 가능하면 약자 사용은 자제
    3. 단수 명사 사용
    4. 모든 엔터티에서 유일하게 이름 부여
    5. 엔터티 생성 의미대로 이름 부여

  - 엔터티와 인스턴스 표기법
    엔터티는 사각형으로 표현, 속성은 조금씩 다름
    ![alt text](/Feb/image/image-12.png)</br>
    ![alt text](/Feb/image/image-11.png)

## 속성(Attribute)
  - 속성은 **업무에서 필요로 하는 고유한 성질, 특징**을 의미(관찰 대상) $\rightarrow$ **컬럼으로 표현할 수 있는 단위**
  - 업무상 인스턴스로 관리하고자 하는 **더 이상 분리되지 않는 최소의 데이터 단위**
  - 인스턴스의 구성 요소</br>
    ex) 학생 엔터티에 이름, 학번, 학과번호 등이 속성이 될 수 있음

  - 엔터티, 인스턴스, 속성, 속성 값의 관계
    1. 한 개의 엔터티는 2개 이상의 인스턴스의 집합이어야 한다. (하나의 테이블은 2개 이상의 행을 가짐)
    2. 한 개의 엔터티는 2개 이상의 속성을 갖는다. (하나의 테이블은 2개 이상의 컬럼으로 구성됨)
    3. 한 개의 속성은 1개의 속성값을 갖는다. (각 컬럼의 값은 하나씩만 삽입 가능)
    4. 속성은 엔터티에 속한 엔터티에 대한 자세하고 구체적인 정보를 나타냄. **각 속성은 구체적인 값**

  - 속성의 특징
    - 반드시 해당 업무에서 필요하고 관리하고자 하는 정보여야 한다.
    - **정해진 주식별자에 함수적 종속성을 가져야 한다.**
    - 하나의 속성은 한 개의 값만을 가진다.(한 컬럼의 값은 각 인스턴스마다 하나씩만 저장)
    - 하나의 속성에 여러 개의 값이 있는 다중 값일 경우 별도의 엔터티를 이용하여 분리한다.
    - 하나의 인스턴스는 속성마다 반드시 하나의 속성값을 가진다. $\rightarrow$ 각 속성이 하나의 값을 갖고 있음을 의미 (속성의 **원자성**)</br>
    `원자성` : 데이터모델에서 각 엔터티의 인스턴스가 해당 속성에 대해 단일하고 명확한 값을 가지는 것을 의미

  - 함수적 종속성
    - 한 속성의 값이 다른 속성의 값에 종속적인 관계를 갖는 특징을 말한다. 즉, 어떤 속성 A의 값에 의해 다른 속성 B도 유일하게 결정된다면 B는 A에 함수적으로 종속됐다 하고 이를 수식으로 나타내면 
## 관계(Relationship)
![alt text](/Feb/image/image-10.png)
### 오늘의 도전 과제와 해결 방법
- 도전 과제 1: 도전 과제에 대한 설명 및 해결 방법
- 도전 과제 2: 도전 과제에 대한 설명 및 해결 방법

### 오늘의 회고
- 오늘의 학습 경험에 대한 자유로운 생각이나 느낀 점을 기록합니다.
- 성공적인 점, 개선해야 할 점, 새롭게 시도하고 싶은 방법 등을 포함할 수 있습니다.

### 참고 자료 및 링크
- [NumPy - Array creation](https://numpy.org/doc/stable/user/basics.creation.html)
- [링크 제목](URL)